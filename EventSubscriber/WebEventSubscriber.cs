using Microsoft.AspNet.SignalR.Client;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using System.Threading;

namespace EventSubscriber
{
    /// <summary>
    /// Handles receiving events from the Web Event Bridge
    /// </summary>
    class WebEventSubscriber
    {
        class ConnectionInfo
        {
            // ReSharper disable NotAccessedField.Local
            public string SessionToken;
            public string ApplicationId;
            // ReSharper restore NotAccessedField.Local
        }

        /// <summary>
        /// Constructor accepting an event subscription
        /// </summary>
        /// <param name="webEventBridgeUri">The Web Event Bridge URI</param>
        /// <param name="openAccessSessionToken">The OpenAccess API session token</param>
        /// <param name="openAccessApplicationId">The OpenAccess API application id</param>
        /// <param name="subscription">The event subscription</param>
        /// <param name="businessEventSubscriberHandler">The business event subscriber handler</param>
        /// <param name="traceLevel">the SignalR trace level</param>
        public WebEventSubscriber(string webEventBridgeUri, OpenAccessService service, EventSubscription subscription, IBusinessEventSubscriberHandler businessEventSubscriberHandler, TraceLevels traceLevel = TraceLevels.None)
        {
            this.webEventBridgeUri = webEventBridgeUri;
            this.service = service;
            this.openAccessConnectionInfo = new ConnectionInfo
            {
                SessionToken = service.SessionToken,
                ApplicationId = service.ApplicationId,
            };
            this.subscription = subscription;
            this.businessEventSubscriberHandler = businessEventSubscriberHandler;
            this.traceLevel = traceLevel;
            this.connectionHeartbeatThread = new Thread(ConnectionHeartbeatThread);
            this.connectionHeartbeatCancellation = new CancellationTokenSource();
        }

        /// <summary>
        /// Starts receiving events
        /// </summary>
        public void StartReceiving()
        {
            GetWebEventBridgeProxy().Invoke<EventSubscription>("ModifySubscription", openAccessConnectionInfo, subscription).ContinueWith(OnModifySubscription);
        }

        /// <summary>
        /// Stops receiving events
        /// </summary>
        public void StopReceiving()
        {
            this.connectionHeartbeatCancellation.Cancel();
            this.connectionHeartbeatThread.Join();
            GetWebEventBridgeProxy().Invoke("StopSubscription").ContinueWith(OnStopSubscription);

        }

        /// <summary>
        /// Callback that handles the asynchronous task when the ModifySubscription call was invoked
        /// </summary>
        /// <param name="task">Holds the tasks detail information</param>
        private void OnModifySubscription(Task<EventSubscription> task)
        {
            if (task.IsFaulted)
                businessEventSubscriberHandler.OnExceptionRaised(task.Exception);
            else
            {
                subscription = task.Result;
                this.connectionHeartbeatThread.Start();
            }
        }

        /// <summary>
        /// Disconnects from the message bus to stop receiving business events.
        /// </summary>
        /// <param name="task">Holds the tasks detail information</param>
        private void OnStopSubscription(Task task)
        {
            if (task.IsFaulted)
                businessEventSubscriberHandler.OnExceptionRaised(task.Exception);
        }

        /// <summary>
        /// Returns the references to the proxy of the Web Event Bridge service
        /// </summary>
        /// <returns>The references to the IHubProxy of the Web Event Bridge service</returns>
        protected IHubProxy GetWebEventBridgeProxy()
        {
            if (webEventBridgeProxy == null)
            {
                connection = new HubConnection(webEventBridgeUri);

                if (traceLevel != TraceLevels.None)
                {
                    connection.TraceLevel = traceLevel;
                    var writer = new StreamWriter($"trace{subscription.id}.log");
                    writer.AutoFlush = true;
                    connection.TraceWriter = writer;
                }

                webEventBridgeProxy = connection.CreateHubProxy(HubName);

                // register callbacks for the event that will be generated by service
                webEventBridgeProxy.On<IDictionary<string, object>>("OnBusinessEventReceived", OnBusinessEventReceived);
                webEventBridgeProxy.On<string>("OnExceptionRaised", OnExceptionRaised);
                webEventBridgeProxy.On("OnConnectionFromMessageBusLost", OnConnectionFromMessageBusLost);
                webEventBridgeProxy.On("OnConnectionToMessageBusEstablished", OnConnectionToMessageBusEstablished);
                webEventBridgeProxy.On<string>("OnManagementEvent", OnManagementEvent);

                connection.Start().ContinueWith(OnConnectionStart).Wait();
            }
            return webEventBridgeProxy;
        }

        /// <summary>
        /// Called by the framework when a management event is received by the event bridge and is pushed to the web client
        /// </summary>
        /// <param name="message"></param>
        protected void OnManagementEvent(string message)
        {
            businessEventSubscriberHandler.OnManagementEvent(message);
        }

        /// <summary>
        /// Called by the framework when a business event is received by the event bridge and is pushed to the web client
        /// </summary>
        /// <param name="eventProperties">The business event properties</param>
        protected virtual void OnBusinessEventReceived(IDictionary<string, object> eventProperties)
        {
            businessEventSubscriberHandler.OnBusinessEventReceived(eventProperties);
        }

        /// <summary>
        /// Called by the framework when an error occurred in the event bridge and is pushed to the web client
        /// </summary>
        /// <param name="message">Holds the business event information</param>
        protected virtual void OnExceptionRaised(string message)
        {
            businessEventSubscriberHandler.OnExceptionRaised(new AggregateException(new Exception(message)));
        }

        /// <summary>
        /// Called by the framework when the connection to Message bus is lost in the event bridge and is pushed to the web client
        /// </summary>
        protected virtual void OnConnectionFromMessageBusLost()
        {
            businessEventSubscriberHandler.OnConnectionLost();
        }

        /// <summary>
        /// Called by the framework when the connection to Message bus is established in the event bridge and is pushed to the web client
        /// </summary>
        protected virtual void OnConnectionToMessageBusEstablished()
        {
            businessEventSubscriberHandler.OnConnectionEstablished();
        }

        /// <summary>
        /// Callback that handles the asynchronous task when Starting the connection to the Event Bridge 
        /// </summary>
        /// <param name="task">Holds the tasks detail information</param>
        protected void OnConnectionStart(Task task)
        {
            if (!task.IsFaulted) return;

            if (task.Exception != null)
                OnManagementEvent(task.Exception.Message);
        }

        private void ConnectionHeartbeatThread()
        {
            bool isSessionTokenExpired = false;
            bool isConnectionLost = false;
            while (!this.connectionHeartbeatCancellation.Token.WaitHandle.WaitOne(10 * 1000))
            {
                try
                {
                    if (isSessionTokenExpired)
                    {
                        Program.Authenticate(this.service);
                        this.openAccessConnectionInfo.SessionToken = this.service.SessionToken;
                        isSessionTokenExpired = false;
                    }

                    if (isConnectionLost)
                    {
                        var task = connection.Start();
                        task.Wait();
                        isConnectionLost = task.IsFaulted;
                    }

                    if (!isConnectionLost)
                    {
                        var task = GetWebEventBridgeProxy().Invoke("ConnectionHeartbeat", openAccessConnectionInfo, subscription);
                        task.Wait();
                        isConnectionLost = task.IsFaulted;
                    }
                }
                catch (OpenAccessException oaException)
                {
                    // We cannot recover if failed to authenticate OpenAccess.
                    if (IsInvalidLoginException(oaException))
                    {
                        Console.WriteLine("Error authenticating with the OpenAccess API: {0} - {1}", oaException.Code, oaException.Message);
                        Console.WriteLine("Press any key to exit...");
                        return;
                    }
                }
                catch (AggregateException aggregateException)
                {
                    // We cannot recover if subscription was deleted
                    if (IsSubscriptionNotExistException(aggregateException))
                    {
                        Console.WriteLine("The subscription was deleted.");
                        Console.WriteLine("Press any key to exit...");
                        return;
                    }
                }
                catch (Exception e)
                {
                    isSessionTokenExpired = IsSessionTokenExpiredException(e);
                    isConnectionLost = true;
                }
            }
        }

        private bool IsSubscriptionNotExistException(AggregateException e)
        {
            if (e != null && e.InnerException is Microsoft.AspNet.SignalR.Client.HubException)
            {
                var hubException = e.InnerException as Microsoft.AspNet.SignalR.Client.HubException;
                return hubException != null && hubException.ErrorData != null && hubException.ErrorData.ToString().Contains("system.not_found");
            }
            return false;
        }

        private bool IsSessionTokenExpiredException(Exception e)
        {
            HubException hubException = null;
            if (e is HubException)
                hubException = e as HubException;
            else if (e.InnerException is HubException)
                hubException = e.InnerException as HubException;

            if (hubException != null && hubException.ErrorData != null)
            {
                var errorCode = hubException.ErrorData.ToString();
                return errorCode.Contains("openaccess.general.invalidsessiontoken");
            }

            return false;
        }

        private bool IsInvalidLoginException(OpenAccessException e)
        {
            return e.Code != null && e.Code.StartsWith("openaccess.");
        }

        /// <summary>
        /// The Web Event Bridge URI
        /// </summary>
        private string webEventBridgeUri;

        /// <summary>
        /// Holds the name of the Hub that provides the Event Bridge Outbound Web Event delivery service
        /// </summary>
        private const string HubName = "Outbound";

        /// <summary>
        /// Holds the connection to the service Hub
        /// </summary>
        private HubConnection connection;

        /// <summary>
        /// The event subscription for which to receive events
        /// </summary>
        private EventSubscription subscription;

        /// <summary>
        /// The underlying Web Event Bridge proxy, for receiving events
        /// </summary>
        private IHubProxy webEventBridgeProxy;
        
        /// <summary>
        /// The business event subscriber handler
        /// </summary>
        private IBusinessEventSubscriberHandler businessEventSubscriberHandler;

        /// <summary>
        /// The OpenAccess connection information (session token and application id)
        /// </summary>
        private ConnectionInfo openAccessConnectionInfo;

        /// <summary>
        /// The trace level for the SignalR connection
        /// </summary>
        private TraceLevels traceLevel;

        private Thread connectionHeartbeatThread;

        private CancellationTokenSource connectionHeartbeatCancellation;

        private OpenAccessService service;
    }
}
